///////////////////////////////////////////////////////////
//  RotationInterpolator.as
//  Macromedia ActionScript Implementation of the Class RotationInterpolator
//  Generated by Enterprise Architect
//  Created on:      26-VII-2006 13:46:08
//  Original author: Thomas Pfeiffer - kiroukou
///////////////////////////////////////////////////////////
package sandy.core.transform
{
	import flash.events.Event;
	
	import sandy.core.World3D;
	import sandy.core.data.Vector;
	import sandy.math.VectorMath;
	/**
	* RotationInterpolator
	* @author		Thomas Pfeiffer - kiroukou
	* @version		1.0
	* @date 		23.06.2006
	**/
	public class RotationInterpolator extends BasicInterpolator implements Interpolator3D
	{
		 /**
		 * RotationInterpolator
		 * <p> This class realise a rotation interpolation of the group of objects it has been applied to</p>
		 * @param f Function 	The function generating the interpolation value. 
		 * 						You can use what you want even if Sandy recommends the Ease class
		 * 						The function must return a number between [0,1] and must have a parameter between [0,1] too.
		 * @param onFrames Number	The number of frames that would be used to do the interpolation. 
		 * 							The smaller the faster the interpolation will be.
		 * @param pmin Number [facultative]The value containing the original rotation offset that will be applied to the object's vertex. Default value is 0.
		 * @param pmax Number [facultative]The value containing the final rotation offset to apply to the object's vertex. Default value is 360.
		 * 
		 */
		public function RotationInterpolator( f:Function, pnFrames:Number, pmin:Number=0, pmax:Number=360 )
		{
			super( f, pnFrames );
			_vAxis = new Vector( 0, 1, 0 );
			_vRef = null;
			_nMin = pmin;
			_nMax = pmax;
			_nDiff = _nMax - _nMin;
			_eOnProgress.setTransformType( getType() );
			_eOnStart.setTransformType( getType() );
			_eOnEnd.setTransformType( getType() );
			_eOnResume.setTransformType( getType() );
			_eOnPause.setTransformType( getType() );
			World3D.addEventListener( World3D.onRenderEVENT, __render );
		}
		
		public function getAxisOfRotation ( ):Vector
		{
			return _vAxis;
		}
		
		/**
		 * Allows you to change the axis of rotation. This axis will be automatically be normalized!
		 * If the axis components are very small the rotation will be paused automatically until you change the axis.
		 * @param v Vector the vector that contains the axis components.
		 * @return Nothing
		 */
		public function setAxisOfRotation ( v:Vector ):void
		{
			if( Math.abs( v.x ) < 0.001 && Math.abs( v.y ) < 0.001 && Math.abs( v.z ) < 0.001 )
			{
				_blocked = true;
			}
			else
			{
				_blocked = false;
				_vAxis = v;
				VectorMath.normalize( _vAxis );
			}
		}
			
		/**
		 * Allows you to make your object rotate around a specific position and not anymore around its center.
		 * The value passed in argument represents an offset to the object position. It is NOT the real position of the rotation center.
		 * @param v Vector the offset to apply to change the rotation center.
		 * @return Nothing
		 */
		public function setPointOfReference ( v:Vector ):void
		{
			_vRef = v;
		}
		
		/**
		* Allows you to change the angles of rotation during the interpolation or once it is finished.
		* If no values are given the default one will be set (0 and 360)
		* @param	start Number the angle you want to start rotating.
		* @param	end Number the angle you want your interpolation finish.
		*/
		public function setAngles( start:Number=0, end:Number=360 ):void
		{
			_nMin = start;
			_nMax = end;
			_nDiff = _nMax - _nMin;
		}
	
		/**
		* Render the current node. This interpolator makes this method being called every World3D render call.
		* @param	Void
		*/
		private function __render(e:Event=null):void
		{
			if( false == _paused && false == _finished )
			{
				// special condition because blocked doesn't mean stopped. It just block the rendering
				if( false == _blocked )
				{
					var current:Number;
					// --
					if( _way == 1 )	current = _nMin + _nDiff * _f ( _p );
					else			current = _nMax - _nDiff * _f ( _p );
					// --
					if( null == _vRef )	_t.rotAxis( _vAxis, current );
					else				_t.rotAxisWithReference( _vAxis, _vRef, current );
					// -- increasing our percentage
					if( _p < 1 && (_p + _timeIncrease) >=1 )
						_p = 1;
					else
						_p += _timeIncrease;
				}
				// --
				if (_p > 1)
				{
					_p = 0;
					_finished = true;
					dispatchEvent( _eOnEnd );
				}
				else
				{
					// -- we broadcast to the group that we have updated our transformation vector
					_eOnProgress.setPercent( _p );
					dispatchEvent( _eOnProgress );
				}
			}
		}
	
		/**
		* Returns the type of the interpolation. 
		* @param	Void
		* @return TransformType the type of the interpolation
		*/
		public override function getType():uint 
		{
			return TransformType.ROTATION_INTERPOLATION;
		}
		
		public override function toString():String
		{
			return 'sandy.core.transfrom.RotationInterpolator';
		}
	
		////////////////
		//// PRIVATE
		////////////////
		private var _vAxis:Vector;
		private var _vRef:Vector;
		private var _nMin:Number;
		private var _nMax:Number;
		private var _nDiff:Number;
		
	}
}
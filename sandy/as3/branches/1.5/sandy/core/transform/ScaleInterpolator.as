///////////////////////////////////////////////////////////
//  ScaleInterpolator.as
//  Macromedia ActionScript Implementation of the Class ScaleInterpolator
//  Generated by Enterprise Architect
//  Created on:      26-VII-2006 13:46:08
//  Original author: Thomas Pfeiffer - kiroukou
///////////////////////////////////////////////////////////
package sandy.core.transform
{
	import sandy.core.transform.Interpolator3D;
	import sandy.core.data.Vector;
	import sandy.core.transform.BasicInterpolator;
	import sandy.events.InterpolationEvent;
	import sandy.math.VectorMath;
	import sandy.core.World3D;
	import sandy.core.transform.TransformType;
	
	/**
	* ScaleInterpolator
	*  
	* @author		Thomas Pfeiffer - kiroukou
	* @version		1.0
	* @date 		05.08.2006
	**/
	public class ScaleInterpolator extends BasicInterpolator implements Interpolator3D
	{
		/**
		 * Create a new ScaleInterpolator.
		 * <p> This class realise a scale interpolation of the group of objects it has been applied to</p>
		 * @param f Function 	The function generating the interpolation value. 
		 * 						You can use what you want even if Sandy recommends the Ease class
		 * 						The function must return a number between [0,1] and must have a parameter between [0,1] too.
		 * @param onFrames Number	The number of frames that would be used to do the interpolation. 
		 * 							The smaller the faster the interpolation will be.
		 * @param min Vector The vector containing the initial scale values.
		 * @param max Vector The vector containing the final scale values.
		 */
		public function ScaleInterpolator( f:Function, pnFrames:Number, min:Vector, max:Vector ) 
		{
			super( f, pnFrames );	
			_vMin = min;
			_vMax = max;
			_vDiff = VectorMath.sub( _vMax, _vMin );
			_eOnProgress.setTransformType( getType() );
			_eOnStart.setTransformType( getType() );
			_eOnEnd.setTransformType( getType() );
			_eOnResume.setTransformType( getType() );
			_eOnPause.setTransformType( getType() );
			World3D.addEventListener( World3D.onRenderEVENT, __render );
		}
			
		
		private function __render(e:Event=null):void
		{
			if( false == _paused && false == _finished )
			{
				var current:Number = _f( _p );
				if( _way == -1 ) current = 1 - current;
				// computing the new position
				var v:Vector = VectorMath.scale( _vDiff, current );
				v = VectorMath.addVector( _vMin, v );
				//
				_t.scale( v.x, v.y, v.z );
				// increasing our percentage
				if( _p < 1 && (_p + _timeIncrease) >=1 )
				{
					_p = 1;
				}
				else
				{
					_p += _timeIncrease;
				}
				// -- 
				if (_p > 1)
				{
					_p = 0;
					_finished = true;
					dispatchEvent( _eOnEnd );
				}
				else
				{
					// -- we broadcast to the group that we have updated our transformation vector
					_eOnProgress.setPercent( _p );
					dispatchEvent( _eOnProgress );
				}
			}
		}
		
		/**
		* Returns the type of the interpolation. 
		* @param	Void
		* @return TransformType the type of the interpolation
		*/
		public override function getType():uint 
		{
			return TransformType.SCALE_INTERPOLATION;
		}
		
		public override function toString():String
		{
			return 'sandy.core.transfrom.ScaleInterpolator';
		}
		//////////////
		/// PRIVATE
		//////////////
		private var _vMin:Vector;
		private var _vMax:Vector;
		private var _vDiff:Vector;
	}
}
///////////////////////////////////////////////////////////
//  ZLightenSkin.as
//  Macromedia ActionScript Implementation of the Class ZLightenSkin
//  Generated by Enterprise Architect
//  Created on:      26-VII-2006 13:46:11
//  Original author: Andre Michelle and Sandy's port by Thomas Pfeiffer - kiroukou
///////////////////////////////////////////////////////////

package sandy.skin
{
	import flash.display.Sprite;
	import flash.geom.Matrix;
	import flash.geom.Point;
	
	import sandy.core.Object3D;
	import sandy.core.World3D;
	import sandy.core.data.BBox;
	import sandy.core.data.Matrix4;
	import sandy.core.data.Vector;
	import sandy.core.data.Vertex;
	import sandy.core.face.Face;
	import sandy.math.ColorMath;
	import sandy.math.Matrix4Math;
	
	/**
	 * ZLightenSkin From an original code from Andre Michelle (www.andre-michelle.com).
	 * All credits belongs to Andre Michelle. Adaptation to Sandy's engine and
	 * optimizations by Thomas PFEIFFER
	 * @since		1.0
	 * @author Andre Michelle and Sandy's port by Thomas Pfeiffer - kiroukou
	 * @version 1.0
	 * @date 		12.04.2006
	 * @created 26-VII-2006 13:46:11
	 */
	public class ZLightenSkin extends BasicSkin implements Skin
	{
	    private var _blendMoveActive: Boolean;
	    private var _matrix: Matrix;
	    private var _oCol: Object;
	    private var _p: Point;


		/**
	     * Create a new Zlighting skin thnaks to a gradient effect. IMPORTANT : Be
	     * carefull with the value of color! Depending on the value passed, the skin might
	     * gives some strange results. I'm working on it!
	     * 
	     * @param col    Number	the color of the object in hexa
	     */
	    public function ZLightenSkin(col:Number)
	    {
	    	super();
			_p = new Point(0, 0);
			// -- 
			_useLight = false;
			// --
			_blendMoveActive = false;
			//
			_matrix = new Matrix();
			// -- 
			_oCol = {r:1.0, g:1.0, b:1.0 };
			if( col )
			{
				_oCol = ColorMath.hex2rgbn( col );
			}
	    }
	    
	    /**
	     * Start the rendering of the Skin
	     * 
	     * @param f    The face which is being rendered
	     * @param mc    The mc where the face will be build.
	     */
	    public function begin(f:Face, mc:Sprite): void
	    {
	    	var vert:Array = new Array(3);
			var v0:Vertex; vert[0] = f['_va'];
			var v1:Vertex; vert[1] = f['_vb'];
			var v2:Vertex; vert[2] = f['_vc'];
			//-- we sort the vertices depending of their depth. This is usefull since the computations above needs an ordered array.
			var zIndices: Array = vert.sortOn( 'wz', Array.NUMERIC | Array.RETURNINDEXEDARRAY );
			v0 = vert[zIndices[0]];
			v1 = vert[zIndices[1]];
			v2 = vert[zIndices[2]];
			// --
			var x0: Number = v0.sx;
			var y0: Number = v0.sy;
			var x1: Number = v1.sx;
			var y1: Number = v1.sy;
			var x2: Number = v2.sx;
			var y2: Number = v2.sy;
			// -- we use the normal, so we need to create it and project it.
			var vn:Vector 	= f.createNormale();
			var mp:Matrix4 	= World3D.getCurrentProjectionMatrix();
			Matrix4Math.projectVector( mp, vn );
			var nx: Number = vn.x;
			var ny: Number = vn.y;
			// we normalize the normal, important step!
			var nl: Number = Math.sqrt( nx * nx + ny * ny );
			nx /= nl;
			ny /= nl;
			//-- compute gray values
			var aB:BBox = Object3D(f['_o']).getBounds();
			var diff:Number = aB.max.wz - aB.min.wz;
			// --
			var g0: Number = 0xff - ( v0.wz - aB.min.wz ) / diff * 0xff;
			var g1: Number = 0xff - ( v2.wz - aB.min.wz ) / diff * 0xff;
			//-- compute gradient matrix
			var dx20: Number = x2 - x0;
			var dy20: Number = y2 - y0;
			var zLen: Number = nx * dx20 + ny * dy20;
			var zLen2: Number = zLen * 2;
			// --
			_matrix.createGradientBox( zLen2, zLen2, Math.atan2( ny, nx ), x0 - zLen, y0 - zLen );
			if( _blendMoveActive ) mc.blendMode = 'lighten';
			//-- draw gradient
			mc.filters = _filters;
			mc.graphics.beginGradientFill( 'linear', [ ( g0 << 16 )*_oCol.r | ( g0 << 8 )*_oCol.g | g0*_oCol.b, ( g1 << 16 )*_oCol.r | ( g1 << 8 )*_oCol.g | g1*_oCol.b ], [ 100, 100 ], [ 128, 0xff ], _matrix );
	    }

	    /**
	     * Finish the rendering of the Skin
	     * 
	     * @param f    The face which is being rendered
	     * @param mc    The mc where the face will be build.
	     */
	    public function end(f:Face, mc:Sprite): void
	    {
	    	mc.graphics.endFill();
	    }

		/**
	     * Enable (true value) or disable (false value) the blend mode. The blend mode
	     * allows a kind of transparency
	     * 
	     * @param b    Boolean true to enable the blend mode , false otherwise
	     */
	    public function enableBlendMode(b:Boolean): void
	    {
	    	_blendMoveActive = b;
	    }
	    
	    /**
	     * getType, returns the type of the skin
	     * @return	The appropriate SkinType
	     * 
	     * @param Void
	     */
	    public override function getType(): uint
	    {
	    	return SkinType.ZLIGHTEN;
	    }

	    /**
	     * setLightingEnable. Prepare the skin to use the world light or not. The default
	     * value is false. IMPORTANT : With this skin the light doesn't matter. The effect
	     * is done differently and light is useless here.
	     * @return	Void
	     * 
	     * @param bool    Boolean	true is the skin use the light of the world, false if no.
	     */
	    public override function setLightingEnable(bool:Boolean): void
	    {
	    }

	    /**
	     * 
	     * @param Void
	     */
	    public override function toString(): String
	    {
	    	return 'sandy.skin.ZLightenSkin';
	    }
	    
	    /////////////
		// SETTERS //
		/////////////
		
	    public function set color( n:Number ):void
		{
			_oCol = ColorMath.hex2rgbn( n );
			dispatchEvent( _eOnUpdate );
		}
		
		/////////////
		// GETTERS //
		/////////////	
	
		public function get color():Number
		{
			return ColorMath.rgb2hex( _oCol.r, _oCol.g, _oCol.b );
		}	
	

	    

	}//end ZLightenSkin

}
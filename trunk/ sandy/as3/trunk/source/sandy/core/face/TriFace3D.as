///////////////////////////////////////////////////////////
//  TriFace3D.as
//  Macromedia ActionScript Implementation of the Class TriFace3D
//  Generated by Enterprise Architect
//  Created on:      26-VII-2006 13:46:10
//  Original author: Thomas Pfeiffer - kiroukou
///////////////////////////////////////////////////////////
package sandy.core.face
{
	import sandy.core.data.UVCoord;
	import sandy.core.data.Vertex;
	import sandy.core.face.Face;
	import sandy.core.Object3D;
	import sandy.skin.Skin;
	import sandy.events.ObjectEvent;
	import sandy.core.data.Vector;
	import sandy.math.VectorMath;
	
	import flash.events.EventDispatcher;
	import flash.events.Event;
	import flash.events.MouseEvent;
	import flash.display.Sprite;
	import flash.geom.Matrix;
	/**
	* TriFace3D
	* This class is the origin to all the faces. It represents the face of the object, so the visible part of it.
	* Without faces objects an object isn't displayable.
	* @author		Thomas Pfeiffer - kiroukou
	* @version		1.0
	* @date 		05.08.2006 
	**/
	public class TriFace3D extends EventDispatcher implements Face
	{
		/**
		 * Array containing UV coordinates.
		 */
		protected var _aUv:Array;
		
		/**
		* Create a new {@code TriFace3D}.
		* 
		* @param oref A reference to his Object3D;
		* @param pt1 a Vertex;
		* @param pt2 a Vertex;
		* @param pt3 a Vertex;
		*/
		public function TriFace3D( oref:Object3D, pt1:Vertex, pt2:Vertex, pt3:Vertex )
		{
			super( this );
			_o = oref;
			_va = pt1;
			_vb = pt2;
			_vc = pt3;
			_aUv = new Array();
			_bfc = 1;
			_tm = null;
			_mc = null;
			_id = TriFace3D._ID_ ++;
		}
		
		/**
		* Allows you to get the vertex of the face. Very usefull when you want to make some calculation on a face after it has been clicked.
		* @param	Void
		* @return Array The array of vertex.
		*/
		public function getVertex():Array
		{
			return [ _va, _vb, _vc ];
		}
		
		/**
		* Returns the ID of the current face. This ID is an unique number.
		* @param	Void
		* @return	Number The ID of the face.
		*/
		public function getId():uint
		{
			return _id;
		}
		
		/**
		* Enable or not the events onPress, onRollOver and onRollOut with this face.
		* @param b Boolean True to enable the events, false otherwise.
		*/
		public function enableEvents( b:Boolean ):void
		{
			_bEv = b;
		}
		
		/**
		 * Create a clone of the face.
		 * <p>A clone is a perfect copy of the current {@code TriFace3D}.</p>
		 *
		 * @return	A copy of the current {@code TriFace3D}
		 */	
		public function clone():TriFace3D
		{
			return new TriFace3D( _o, _va, _vb, _vc );
		}
		
		/**
		 * Set up the skin of the face.
		 *
		 * @param	s	The Skin to set.
		 */
		public function setSkin( s:Skin ):void
		{
			_s = s;
		}
		
		/**
		 * Get the skin of the face
		 *
		 * @return	The Skin
		 */
		public function getSkin():Skin
		{
			return _s;
		}
		/**
		 * Set up the back skin of the face.
		 * It corresponds to the skin that is applied to the back of the face, so to the faces that is normally hidden to 
		 * the user but that is visible if you've set {@code Object3D.drawAllFaces} to true.
		 * @param	s	The Skin to set.
		 */
		public function setBackSkin( s:Skin ):void
		{
			_sb = s;
		}
		
		/**
		 * Returns the the skin of the back of this face.
		 * @see Face.setBackSkin
		 * @return	The Skin
		 */
		public function getBackSkin():Skin
		{
			return _sb;
		}
		
		/**
		 * Set a new texture coordinates points refers.
		 * @param	a	{code UVCoord}
		 * @param	b	{code UVCoord}
		 * @param	c	{code UVCoord}
		 */	
		public function setUVCoordinates( a:UVCoord, b:UVCoord, c:UVCoord ):void
		{
			_aUv.push(a, b, c);
		}
		
		public function getUVCoords():Array
		{
			return _aUv;
		}
		
		/**
		 * Create the normal vector of the face.
		 *
		 * @return	The resulting {@code Vertex} corresponding to the normal.
		 */	
		public function createNormale():Vector
		{
			var v:Vector, w:Vector;
			var a:Vertex = _va, b:Vertex = _vb, c:Vertex = _vc;
			v = new Vector( b.tx - a.tx, b.ty - a.ty, b.tz - a.tz );
			w = new Vector( b.tx - c.tx, b.ty - c.ty, b.tz - c.tz );
			// -- we compute de cross product
			_vn = VectorMath.cross( v, w );//new Vector( (w.y * v.z) - (w.z * v.y) , (w.z * v.x) - (w.x * v.z) , (w.x * v.y) - (w.y * v.x) );
			// -- we normalize the resulting vector
			VectorMath.normalize( _vn ) ;
			// -- we return the resulting vertex
			return _vn;
		}
	
		/**
		 * Set the normal vector of the face.
		 *
		 * @param	Vertex
		 */
		public function setNormale( n:Vector ):void
		{
			_vn = n;
		}
		
		/**
		 * isvisible 
		 * <p>Say if the face is visible or not</p>
		 *
		 * @param Void
		 * @return a Boolean, true if visible, false otherwise
		 */	
		public function isVisible(): Boolean
		{
			return _bV = (  _bfc * ((_vb.sx - _va.sx)*(_vc.sy - _va.sy)-(_vb.sy - _va.sy)*(_vc.sx - _va.sx)) > 0 );
		}
		
		/** 
		 * Render the face into a Sprite.
		 *
		 * @param	{@code mc}	A {@code Sprite}.
		 */
		public function render( mc:Sprite ):void
		{
			_mc = mc;
			if( _bEv) __prepareEvents( mc );
			// -- we launch the rendering with the appropriate skin
			( _bV ) ? _s.begin( this, mc ) : _sb.begin( this, mc );
			mc.graphics.moveTo( _va.sx, _va.sy );
			mc.graphics.lineTo( _vb.sx, _vb.sy);
			mc.graphics.lineTo( _vc.sx, _vc.sy );
			mc.graphics.lineTo( _va.sx, _va.sy );
			// -- we launch the rendering with the appropriate skin
			( _bV ) ? _s.end( this, mc ) : _sb.end( this, mc );
		}
	
		/** 
		 * Refresh the face display
		 */
		public function refresh():void
		{
			_mc.graphics.clear();
			( _bV ) ? _s.begin( this, _mc ) : _sb.begin( this, _mc );
			_mc.graphics.moveTo( _va.sx, _va.sy );
			_mc.graphics.lineTo( _vb.sx, _vb.sy);
			_mc.graphics.lineTo( _vc.sx, _vc.sy );
			_mc.graphics.lineTo( _va.sx, _va.sy );
			( _bV ) ? _s.end( this, _mc ) : _sb.end( this, _mc );
		}
		
		/**
		 * Return the depth average of the face.
		 * <p>Useful for z-sorting.</p>
		 *
		 * @return	A Number as depth average.
		 */
		public function getZAverage():Number
		{
			// -- We normalize the sum and return it
			return ( ( _va.wz+_vb.wz+_vc.wz ) / 3 );
		}
		
		/**
		 * Returns the min depth of its vertex.
		 * @param Void	
		 * @return number the minimum depth of it's vertex
		 */
		public function getMinDepth ():Number
		{
			return Math.min( _va.wz, Math.min( _vb.wz, _vc.wz ) ) ;
		}
	
		/**
		 * Returns the max depth of its vertex.
		 * @param Void	
		 * @return number the maximum depth of it's vertex
		 */
		public function getMaxDepth ():Number
		{
			return Math.max( _va.wz, Math.max( _vb.wz, _vc.wz ) ) ;
		}
		
		/**
		* Get a String represntation of the {@code TriFace3D}.
		* 
		* @return	A String representing the {@code TriFace3D}.
		*/
		public override function toString():String
		{
			return "sandy.core.face.TriFace3D";
		}
		
		/**
		* This method change the value of the "normal" clipping side.
		* @param	Void
		*/
		public function swapCulling():void
		{
			_bfc *= -1;
		}
		
		public function getTextureMatrix():Matrix
		{
			return _tm;
		}
		
		public function setTextureMatrix( m:Matrix=null ):void
		{
			_tm = m;
		}
		
		public function free():void
		{
			if( _mc )
			{
				var i:uint;
				for( i = 0; i < _mc.numChildren; i++ )
				{
					_mc.removeChildAt(i);
				}
				if( _mc.parent )
				{
					_mc.parent.removeChild( _mc );
				}
				_mc.graphics.clear();					
				_mc = null;
			}
		}	
		
		//////////////
		/// PRIVATE
		//////////////
		protected function __prepareEvents( mc:Sprite ):void
		{
			mc.addEventListener( MouseEvent.CLICK, __onPressed );
			mc.addEventListener( MouseEvent.ROLL_OVER, __onRollOver );
			mc.addEventListener( MouseEvent.ROLL_OUT, __onRollOut );
		}
	
		private function __onPressed( e:Event ):void
		{
			dispatchEvent( new ObjectEvent( ObjectEvent.onPressEVENT ) );
		}
		private function __onRollOver( e:Event ):void
		{
			dispatchEvent( new ObjectEvent( ObjectEvent.onRollOverEVENT ) );
		}	
		private function __onRollOut( e:Event ):void
		{
			dispatchEvent( new ObjectEvent( ObjectEvent.onRollOutEVENT ) );
		}	
		
		//TODO: must be public or we should implement setters/getters for _o, _va, _vb, _vc
		
		public var _o:Object3D; // reference to is owner object
		public var _va:Vertex;// Vertex representing the first point of the face
		public var _vb:Vertex;// Vertex representing the second point of the face
		public var _vc:Vertex;// Vertex corresponding to the third point of the face
		
		private var _vn:Vector; // Vertex containing the normal of the face
		protected var _s:Skin; // Skin of the face
		protected var _sb:Skin;// Skin of the back the face
		protected var _bV:Boolean;// Boolean that privide a fast information about the visibility of the face
		protected var _bEv:Boolean;// Boolean representing the state of the event activation
		private var _id:uint;// Unique face id
		private var _bfc:int;// normal backface culling side is 1. -1 means that it is the opposite side which is visible
		private static var _ID_:uint = 0;
		protected var _mc:Sprite;// The latest movieclip used to render the face
		private var _tm:Matrix;// precomputed texture matrix
	}
	

}
///////////////////////////////////////////////////////////
//  WrlParser.as
//  Macromedia ActionScript Implementation of the Class WrlParser
//  Generated by Enterprise Architect
//  Created on:      26-VII-2006 13:46:11
//  Original author: Thomas PFEIFFER / kiroukou
///////////////////////////////////////////////////////////

package sandy.util
{
	import flash.events.Event;
	import flash.events.EventDispatcher;
	import flash.events.IOErrorEvent;
	import flash.net.URLLoader;
	import flash.net.URLLoaderDataFormat;
	import flash.net.URLRequest;
	import flash.utils.unescapeMultiByte;
	
	import sandy.core.Object3D;
	import sandy.core.face.TriFace3D;
	import sandy.events.ParserEvent;
	
	
	/**
	 * Parsing *.WRL Files can  handle several mesh definitions in the same file. They
	 * will be added to the same and unique object! IMPORTANT : .WRL files must NOT
	 * have indentation! Please choose the without indentation option before
	 * generation.
	 * @see AseParser
	 * @since 1.0
	 * @author Thomas PFEIFFER / kiroukou
	 * @version 1.0
	 * @created 26-VII-2006 13:46:11
	 */
	public class WrlParser extends EventDispatcher
	{
	    /**
	     * The load has failed
	     */
	    static public var onFailEVENT: String = 'onFailEVENT';
	    /**
	     * The OBject3D object is initialized
	     */
	    static public var onInitEVENT: String = 'onInitEVENT';
	    /**
	     * The load has started
	     */
	    static public var onLoadEVENT: String = 'onLoadEVENT';
	    /**
	     * The load is in progress
	     */
	    static public var onProgressEVENT:String = 'onProgressEVENT';

		private static var _CONTEXT:Object = new Object();
		
		/**
		* Interval of time between two calls to parsing method. A big value makes parsing slower but less CPU intensive.
		*/
		//public static var INTERVAL:Number = 5;
		/**
		* Number of lines parsed after a parsing method call. This is a good factor to change if you want to make your parser faster or less CPU intensive
		*/
		//public static var ITERATIONS_PER_INTERVAL:Number = 10;

		/////////////////////
		///  PROPERTIES   ///
		/////////////////////		
		public const loader:URLLoader = new URLLoader();

	    /**
		* Initialize the object passed in parameter (which should be new) with the datas stored in the ASE file given in second parameter
		* @param	o Object3D 	The Object3D we want to initialize
		* @param	url String	The url of the .ASE file used to initialized the Object3D
		* @param	bReversed	Boolean	[optionnal] If the file contains an object that face orientation is different from
		* Sandy's one, you should set this value to true.
		*/
		public function parse( o:Object3D, url: String, bReversed:Boolean = false): void
		{
			var bR:Boolean = bReversed;
			
			_CONTEXT.object = o;
	    	_CONTEXT.bR = bReversed;
	    	
	    	// Construction d'un objet URLRequest qui encapsule le chemin d'accÃ¨s
			var urlRequest:URLRequest = new URLRequest(url);
			// Ecoute de l'evennement COMPLETE
			loader.addEventListener( Event.COMPLETE, _parse );
			loader.addEventListener( IOErrorEvent.IO_ERROR , _io_error );
			// Lancer le chargement
			loader.dataFormat = URLLoaderDataFormat.TEXT;
			loader.load(urlRequest);

		}		
	
		/**
		* Function is call in case of IO error
		* @param	e IOErrorEvent 	IO_ERROR
		*/
		private function _io_error( e:IOErrorEvent ):void
		{
			dispatchEvent( new ParserEvent( WrlParser.onFailEVENT ) );
		}
		
		private function _parse( e:Event ):void
		{
			dispatchEvent( new ParserEvent( WrlParser.onLoadEVENT ) );
		
			var file:URLLoader = URLLoader(e.target);
			var lines:Array = unescapeMultiByte( (file.data as String ) ).split( '\r\n' );
			
			var content:String = String(lines.join(""));
			
			var objects:Array = new Array();
			var objectsReg:RegExp = /DEF\s*([\w\d-]*)\s*Transform\s*{[\s\n]*translation\s*([-\d.]*)\s*([-\d.]*)\s*([-\d.]*)/ig
			var result:Array = objectsReg.exec(content);		
			while (result != null) 
			{
				objects[result[1]] = new Object();
				objects[result[1]].aOffset = new Array(0, 0, 0);	
				objects[result[1]].aOffset[0] += Number(result[2]);
				objects[result[1]].aOffset[1] += Number(result[3]);
				objects[result[1]].aOffset[2] += Number(result[4]);
				
			    result = objectsReg.exec(content);
			}
			
			//var test = /DEF([\s\d\n\w-.,\]{}\[]*)point\[([\s\d\n-.,]*)\][\n}\s]*coordIndex\s*\[([\s\d\n-.,]*)\][\n}\s]*\]/
			//var objects = /DEF\s*([\w\d-]*)\s*Transform\s*{/
			
			// this works only without normals info
			//var geometryReg:RegExp = /coord\s*DEF\s*([\w\d]*)-COORD\s*Coordinate\s*\{\s*point\s*\[[\s\n]*([\d\n\s-,.]*)\][\n\s}]*coordIndex\s*\[[\s\n]*([\n\s\d,-]*)\]/ig
			
			//this shoudl work also with normal vectors
			var result1:Array;
			var result2:Array;
			
			var geometryReg:RegExp = /(coord\s+DEF\s*([\w\d]+)-COORD\s+Coordinate\s*\{\s*point|coordIndex)\s*\[[\s]*([\d\s-,.]*)\]\s*/ig
			result1 = geometryReg.exec(content);
			result2 = geometryReg.exec(content);
		
			while (result1 != null && result2 != null) 
			{
			    objects[result1[2]].aVertices = result1[3];
			    objects[result1[2]].aFaces = result2[3];
			    
			    result1 = geometryReg.exec(content);
			    result2 = geometryReg.exec(content);
			}
//			var content:String = unescape( this );
			// --
	//		var aObjects:Array	= StringUtil.getTextBetween( content, 'DEF', ']\r\n}' );
			// if no objects were found, it should have only one!
			//if( !aObjects.length ) aObjects[0] = StringUtil.getTextBetween( content, 'DEF', ']\r\n}' );
			//var aVertices:Array = StringUtil.getTextBetween( content, 'point [', ']' );			
			//var aFaces:Array 	= StringUtil.getTextBetween( content, 'coordIndex [', ']' );
			// --
			
			/*if( aVertices.length != aFaces.length )
			{
				trace('.WRL File corrupted');
				trace('vertices definition number : '+aVertices.length);
				trace('faces definition number :'+aFaces.length );
				return;
			}*/
			
			//_CONTEXT.object = o;
			//_CONTEXT.aObjects = aObjects;
			//_CONTEXT.aVertices = aVertices;
			//_CONTEXT.aFaces = aFaces;
			
					
			//-- 
			for (var id:String in objects)
			{
				var object3d:Object = objects[id];
				
				
				// -- local variables
				var coords:Array;
				var f:TriFace3D;
				var i: Number, l:Number, idV:Number;
				//var obj:String 		= _CONTEXT.aObjects.shift();
				//var vertice:String 	= _CONTEXT.aVertices.shift();
				//var face:String 	= _CONTEXT.aFaces.shift();
				var o:Object3D 		= _CONTEXT.object;
				
				var vertices:String = object3d.aVertices;
				var faces:String 	= object3d.aFaces;
				var aOffset:Array 	= object3d.aOffset
				
				if (vertices != null && faces != null)
				{
				
					// to remember to use the good ids for points and faces
					
					idV = o.aPoints.length;
					
					//var svertices:String = vertice.split('\r\n').join('');
					//var sfaces:String = face.split('\r\n').join('');
					// -- we have to clean a bit more the strings
					//svertices 	= StringUtil.replace( svertices, '  ', '' );
					var sfaces:String 		= StringUtil.replace( faces, ' ', '' );
					// --
					var avertices:Array = vertices.split( ',' );
					var afaces:Array	= sfaces.split( ',-1' );
					// --
					l = avertices.length;
					for( i = 0 ; i < l; i++ )
					{
						coords = avertices[ i ].split(' ');
						
						if(i > 0) 
						{
							coords.shift();
						}
						// we get the objet translation => offset coordinates
						o.addPoint(   Number( coords[0] ) + Number( aOffset[0] ), 
									- Number( coords[1] ) - Number( aOffset[1] ), 
									  Number( coords[2] ) + Number( aOffset[2] ));
					}
					l = afaces.length;
					for( i = 0 ; i < l-1; i++ )
					{
						var ids:Array = afaces[ i ].split(',');
						if(i > 0) 
						{
							ids.shift();
						}
						// seems that WRL format use a different face orientation than Sandy
						if( WrlParser._CONTEXT.bR ) 
						{
							ids.reverse();
						}
						o.addFace(  new TriFace3D( o, 	o.aPoints[Number( ids[0] )+idV], 
														o.aPoints[Number( ids[1] )+idV], 
														o.aPoints[Number( ids[2] )+idV] ) );
					}
				}
			}
			dispatchEvent( new ParserEvent( WrlParser.onInitEVENT ) );
		}
		
		/**
		* 
		* @param	url String	The url of the .ASE file used to initialized the Object3D
		*/
		/*
		public static function export( url: String, bReversed:Boolean ):void
		{
			var bR:Boolean = (undefined == bReversed) ? false : true;
			var lv: LoadVars = new LoadVars();
			//--
			lv.onLoad = function( sucess: Boolean ):void
			{
				if( !sucess ) 
				{
					WrlParser.broadcastEvent( new ParserEvent( WrlParser.onFailEVENT ) );
					return;
				}
				var output:String = new String();
				var content:String = unescape( this );
				var i: Number, j:Number, l:Number, n:Number, idV:Number, idTot:Number = 0;
				var coords:Array;
				// --
				var aObjects:Array	= StringUtil.getTextBetween( content, 'DEF', ']\r\n}' );
				// if no objects were found, it should have only one!
				//if( !aObjects.length ) aObjects[0] = StringUtil.getTextBetween( content, 'DEF', ']\r\n}' );
				var aVertices:Array = StringUtil.getTextBetween( content, 'point [', ']' );			
				var aFaces:Array 	= StringUtil.getTextBetween( content, 'coordIndex [', ']' );
				// --
				if( aVertices.length != aFaces.length )
				{
					output += '.WRL File corrupted\n';
					output += 'vertices definition number : '+aVertices.length+'\n';
					output += 'faces definition number :'+aFaces.length;
				}
				for( n = 0; n < aObjects.length; n++ )
				{
					var aOffsets:Array 	= StringUtil.getTextBetween( aObjects[n], 'translation ', '\r\n' );
					var aOffset:Array = [0, 0, 0];
					for ( i = 0; i < aOffsets.length; i++ )
					{
						coords = aOffsets[ i ].split(' ');
						aOffset[ 0 ] += parseFloat( coords[0] );
						aOffset[ 1 ] += parseFloat( coords[1] );
						aOffset[ 2 ] += parseFloat( coords[2] );					
					}
					// to remember to use the good ids for points and faces
					idV = idTot;
					var svertices:String = aVertices[n].split('\r\n').join('');
					var sfaces:String = aFaces[n].split('\r\n').join('');
					// -- we have to clean a bit more the strings
					svertices 	= StringUtil.replace( svertices, '  ', '' );
					sfaces 		= StringUtil.replace( sfaces, ' ', '' );
					// --
					var avertices:Array = svertices.split( ',' );
					var afaces:Array	= sfaces.split( ',-1' );
					// --
					l = avertices.length;
					for( i = 0 ; i < l; i++ )
					{
						coords = avertices[ i ].split('\r\n').join('').split(' ');
						if(i > 0) coords.shift();
						// we get the objet translation => offset coordinates
						output += 'addPoint( '+(parseFloat( coords[0] ) + parseFloat( aOffset[0] ))+','+ 
												(- parseFloat( coords[1] ) - parseFloat( aOffset[1]))+','+ 
												parseFloat( coords[2] ) + parseFloat( aOffset[2] )+');\n';
						idTot++;
					}
					l = afaces.length;
					for( i = 0 ; i < l-1; i++ )
					{
						var ids:Array = afaces[ i ].split(',');
						if(i > 0) ids.shift();
						//var uv:Array = new Array( ids.length );
						//for( j = 0; j < ids.length; j++ )
						//	ids[j] = parseInt( ids[j] )+idV;
						// seems that WRL format use a different face orientation than Sandy
						if( bR ) ids.reverse();
						output += 'addFace( new TriFace3D( this, aPoints['+(parseInt( ids[0] )+idV)+'], aPoints['+(parseInt( ids[1] )+idV)+'], aPoints['+(parseInt( ids[2] )+idV)+'] ) );\n';
					}
				}
				// --
				WrlParser.broadcastEvent( new ParserEvent( WrlParser.onInitEVENT, null, 100,output ) );
			};
			lv.load( url );
			WrlParser.broadcastEvent( new ParserEvent( WrlParser.onLoadEVENT ) );
		}
		*/
	    

	}//end WrlParser

}
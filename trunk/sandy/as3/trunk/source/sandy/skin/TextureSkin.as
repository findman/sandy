///////////////////////////////////////////////////////////
//  TextureSkin.as
//  Macromedia ActionScript Implementation of the Class TextureSkin
//  Generated by Enterprise Architect
//  Created on:      26-VII-2006 13:46:09
//  Original author: Thomas Pfeiffer - kiroukou
///////////////////////////////////////////////////////////
package sandy.skin
{
	import flash.display.BitmapData;
	import flash.filters.ColorMatrixFilter;
	import flash.geom.Matrix;
	import flash.geom.Point;
	import flash.display.Sprite;
	
	import sandy.core.face.Face;
	import sandy.core.light.Light3D;
	import sandy.core.World3D;
	import sandy.math.VectorMath;
	import sandy.skin.Skin;
	import sandy.skin.SkinType;
	import sandy.skin.BasicSkin;
	
	/**
	* TextureSkin
	* @author		Thomas Pfeiffer - kiroukou
	* @version		1.0
	* @date 		05.08.2006 
	**/
	public class TextureSkin extends BasicSkin implements Skin
	{
		/**
		* Create a new TextureSkin.
		* @param t : The actionScriptLink of the bitmap;
		*/
		public function TextureSkin( t:BitmapData )
		{
			super();
			texture = t;
			_p = new Point(0, 0);
			_cmf = new ColorMatrixFilter();
		}
		
		/////////////
		// SETTERS //
		/////////////	
		public function set texture( b:BitmapData ):void
		{
			_texture = b;
			_w = b.width;
			_h = b.height;
			dispatchEvent( _eOnUpdate );
		}	
		/////////////
		// GETTERS //
		/////////////	
		public function get texture():BitmapData
		{
			return _texture;
		}
		
		/**
		 * getType, returns the type of the skin
		 * @param Void
		 * @return	The appropriate SkinType
		 */
		 public override function getType():uint
		 {
		 	return SkinType.TEXTURE;
		 }
		
		/**
		* Start the rendering of the Skin
		* @param f	The face which is being rendered
		* @param mc The mc where the face will be build.
		*/ 	
		public function begin( f:Face, mc:Sprite ):void
		{
			var a:Array = f.getVertex();
			var x0:Number = a[0].sx;
			var y0:Number = a[0].sy;
			var x1:Number = a[1].sx;
			var y1:Number = a[1].sy;
			var x2:Number = a[2].sx;
			var y2:Number = a[2].sy;
			// --
			if( !_w  && !_h ) return;
			// --
			var sMat:Matrix = new Matrix(( x1 - x0 ) / _w, 
										 ( y1 - y0 ) / _w, 
										 ( x2 - x0 ) / _h, 
										 ( y2 - y0 ) / _h, 
										 x0, 
										 y0 );
			// --
			if( null == f.getTextureMatrix() )
			{
				var auv:Array  = f.getUVCoords();	
				var u0: Number = auv[0].u * _w;
				var v0: Number = auv[0].v * _h;
				var u1: Number = auv[1].u * _w;
				var v1: Number = auv[1].v * _h;
				var u2: Number = auv[2].u * _w;
				var v2: Number = auv[2].v * _h;
				// --
				var mat:Matrix = new Matrix( (u1 - u0)/_w, (v1 - v0)/_w, (u2 - u0)/_h, (v2 - v0)/_h, u0, v0 );
				mat.invert();
				f.setTextureMatrix( mat );
			}
			var tMat:Matrix = f.getTextureMatrix();
			//var rMat:Matrix = tMat.clone();
			//rMat.concat( sMat );
			var rMat:Matrix = __concat( tMat, sMat );
			// -- 
			if( _useLight == true )
			{
				//TODO copy only the little part which is needed is the bitmap if possible.
				_tmp = _texture.clone();
				var l:Light3D 	= World3D.getLight();
				var lp:Number	= 0.01 * l.getPower();
				var dot:Number 	= lp - ( VectorMath.dot( l.dir, f.createNormale() ) );
				// -- update the color transform matrix
				_cmf.matrix = __getBrightnessTransform( dot );
				// TODO: Optimize here with a different way to produce the light effect
				// and in aplying the filter only to the considered part of the texture!
				_tmp.applyFilter( _tmp , _tmp.rect, _p,  _cmf );
				mc.filters = _filters;
				mc.graphics.beginBitmapFill( _tmp, rMat, false, false );
			}
			else
			{
				// -- 
				mc.filters = _filters;
				mc.graphics.beginBitmapFill( _texture, rMat, false, false );
			}
		}
		
		/**
		 * 
		 * @param
		 * @return
		 */
		private function __getBrightnessTransform( scale:Number ) : Array
		{
			var s:Number = scale;
			var o:Number = 0;
			//
			return new Array 
			(
				s	, 0.0	, 0.0	, 0.0	, o,
				0.0	, s		, 0.0	, 0.0	, o,
				0.0	, 0.0	, s		, 0.0	, o,
				0.0	, 0.0	, 0.0	, 1.0	, o
			);
		}
	
		/**
		* Finish the rendering of the Skin
		* @param f	The face which is being rendered
		* @param mc The mc where the face will be build.
		*/ 	
		public function end( f:Face, mc:Sprite ):void
		{
			mc.graphics.endFill();
		}
	
		public override function toString():String
		{
			return 'sandy.skin.TextureSkin' ;
		}
		
		private function __concat( m1:Matrix, m2:Matrix ):Matrix
		{	
			var r:Matrix = new Matrix();
			r.a = m1.a * m2.a;
			r.d = m1.d * m2.d;
			r.b = r.c = 0;
			r.ty = m1.ty * m2.d + m2.ty;
			r.tx = m1.tx * m2.a + m2.tx;
			if( m1.b != 0 || m1.c !=0 || m2.b != 0 || m2.c != 0 )
			{
				r.a += m1.b * m2.c;
				r.d += m1.c * m2.b;
				r.b += m1.a * m2.b + m1.b * m2.d;
				r.c += m1.c * m2.a + m1.d * m2.c;
				r.tx += m1.ty * m2.c;
				r.ty += m1.tx * m2.b;
			}
			return r;
		}
		
		private var _w:uint;
		private var _h:uint;
		private var _tmp:BitmapData;
		private var _p:Point;
		private var _cmf:ColorMatrixFilter;
		protected var _texture:BitmapData;
	}

}